#!/usr/bin/env python

'''
Validate layout of generated HTML pages.
(We validate the HTML because source may not be in Markdown.)
'''

import sys
import os
import glob
import fnmatch
import yaml
from optparse import OptionParser
from bs4 import BeautifulSoup
from lxml import etree


# Default configuration.
DEFAULT_CONFIG = '''\
patterns:
  '*.html':
    - 'has_footer'
    - 'has_navbar'
'''


# Record all the rules.
RULES = {}
def rule(fn):
    RULES[fn.__name__] = fn
    return fn


def main():
    '''Main driver: check all files with all rules that apply.'''

    args = parse_args()
    read_config(args)
    docs = read_all_docs(args.source_dir)
    require(docs, 'No source files found in {0}'.format(args.source_dir))
    all_filenames = docs.keys()
    for pattern in args.patterns:
        full_pattern = os.path.join(args.source_dir, pattern)
        for filename in fnmatch.filter(all_filenames, full_pattern):
            for rule in args.patterns[pattern]:
                RULES[rule](filename, docs[filename])


def parse_args():
    '''Parse command-line arguments.'''

    parser = OptionParser()
    parser.add_option('-c', '--config',
                      default=None,
                      dest='config_file',
                      help='configuration file')
    parser.add_option('-s', '--source',
                      default='_site',
                      dest='source_dir',
                      help='source directory')

    args, extras = parser.parse_args()

    require(not extras, 'Unexpected trailing command-line arguments "{0}"'.format(extras))

    return args


def read_config(args):
    '''
    Read configuration file.
    '''

    if args.config_file:
        with open(args.config_file, 'r') as reader:
            args.config = yaml.load(reader)
    else:
        args.config = yaml.load(DEFAULT_CONFIG)

    args.patterns = args.config['patterns']


def read_all_docs(source_dir):
    '''
    Read all HTML pages under the source directory.
    Returns a dictionary of (path, doc).
    '''

    pattern = os.path.join(source_dir, '**/*.html')
    result = {}
    for path in glob.iglob(pattern, recursive=True):
        try:
            with open(path, 'r') as reader:
                raw = reader.read().replace('<!doctype html>\n', '')
                soup = BeautifulSoup(raw, 'html.parser').prettify()
                doc = etree.fromstring(soup)
                result[path] = doc
        except IOError as e:
            print('Unable to open {0}: {1}'.format(path, e), file=sys.stderr)
            sys.exit(1)

    return result


@rule
def has_footer(filename, doc):
    '''Check that document has footer element.'''

    matches = doc.xpath('//footer')
    check_1(filename, 'footers', matches)


@rule
def has_navbar(filename, doc):
    '''Check that document has header element.'''

    matches = doc.xpath('//div[@class]="navbar-header"')
    check_1(filename, 'div navbar', matches)


def check_1(filename, rulename, actual):
    '''Check that an equality holds.'''

    if (type(actual) is not list) or (len(actual) != 1):
        print('In {0}, checking {1}: expected 1 match, got {2}'.format(filename, rulename, actual))


def require(condition, message):
    '''Fail if condition not met.'''

    if not condition:
        print(message, file=sys.stderr)
        sys.exit(1)


if __name__ == '__main__':
    main()
